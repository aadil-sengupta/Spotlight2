"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DailyMediaView = void 0;
var daily_js_1 = __importDefault(require("@daily-co/daily-js"));
var react_native_webrtc_1 = require("@daily-co/react-native-webrtc");
var DailyMediaView_1 = __importDefault(require("./DailyMediaView"));
exports.DailyMediaView = DailyMediaView_1.default;
var iOSCallObjectBundleCache_1 = __importDefault(require("./iOSCallObjectBundleCache"));
require("react-native-url-polyfill/auto"); // Applies global URL polyfill
var react_native_background_timer_1 = __importDefault(require("react-native-background-timer"));
var base_64_1 = require("base-64");
var react_native_1 = require("react-native");
// Preventing RN issue getrandomvalues not supported
// https://github.com/uuidjs/uuid#getrandomvalues-not-supported
require("react-native-get-random-values");
var DailyNativeUtils = react_native_1.NativeModules.DailyNativeUtils, WebRTCModule = react_native_1.NativeModules.WebRTCModule;
var webRTCEventEmitter = new react_native_1.NativeEventEmitter(WebRTCModule);
var dailyNativeUtilsEventEmitter = new react_native_1.NativeEventEmitter(DailyNativeUtils);
var hasAudioFocus;
var appState;
var audioFocusChangeListeners = new Set();
var appStateChangeListeners = new Set();
var systemScreenCaptureStopListeners = new Set();
var systemScreenCaptureStartCallback;
function setupEventListeners() {
    dailyNativeUtilsEventEmitter.addListener('EventOnHostDestroy', function () {
        appStateChangeListeners.forEach(function (listener) { return listener('destroyed'); });
    });
    // audio focus: used by daily-js to auto-mute mic, for instance
    if (react_native_1.Platform.OS === 'android') {
        hasAudioFocus = true; // safe assumption, hopefully
        webRTCEventEmitter.addListener('EventAudioFocusChange', function (event) {
            if (!event || typeof event.hasFocus !== 'boolean') {
                console.error('invalid EventAudioFocusChange event');
            }
            var hadAudioFocus = hasAudioFocus;
            hasAudioFocus = event.hasFocus;
            if (hadAudioFocus !== hasAudioFocus) {
                audioFocusChangeListeners.forEach(function (listener) {
                    return listener(hasAudioFocus);
                });
            }
        });
    }
    // app active state: used by daily-js to auto-mute cam, for instance
    appState = react_native_1.AppState.currentState;
    react_native_1.AppState.addEventListener('change', function (nextState) {
        var previousState = appState;
        appState = nextState;
        var wasActive = previousState === 'active';
        var isActive = appState === 'active';
        if (wasActive !== isActive) {
            appStateChangeListeners.forEach(function (listener) {
                return listener(isActive ? 'active' : 'inactive');
            });
        }
    });
    if (react_native_1.Platform.OS === 'ios') {
        // screen capture stop: used to synchronize JS screen sharing state with iOS
        // system screen capture state, which can be controlled outside the app via
        // the control center or by tapping the notification in the corner.
        dailyNativeUtilsEventEmitter.addListener('EventSystemScreenCaptureStop', function () {
            systemScreenCaptureStopListeners.forEach(function (listener) { return listener(); });
        });
        // when we invoke to start the screen share, we first invoke to start the screen capture
        // and add the listener, so we are only going to start the screen share if the capture has started
        // that is why we just need a single callback
        dailyNativeUtilsEventEmitter.addListener('EventSystemScreenCaptureStart', function () {
            if (systemScreenCaptureStartCallback) {
                systemScreenCaptureStartCallback();
            }
        });
    }
}
function setupGlobals() {
    // WebRTC APIs + global `window` object
    (0, react_native_webrtc_1.registerGlobals)();
    // A shim to prevent errors in call machine bundle (not ideal)
    global.window.addEventListener = function () { };
    global.window.removeEventListener = function () { };
    global.btoa = base_64_1.encode;
    global.atob = base_64_1.decode;
    // A workaround for iOS HTTP cache not caching call object bundle due to size
    if (react_native_1.Platform.OS === 'ios') {
        global.iOSCallObjectBundleCache = iOSCallObjectBundleCache_1.default;
    }
    // Let timers run while Android app is in the background.
    // See https://github.com/jitsi/jitsi-meet/blob/caabdadf19ae5def3f8173acec6c49111f50a04e/react/features/mobile/polyfills/browser.js#L409,
    // where this technique was borrowed from.
    // For now we don't need this for iOS since we're recommending that apps use
    // the "voip" background mode capability, which keeps the app running normally
    // during a call.
    if (react_native_1.Platform.OS === 'android') {
        global.clearTimeout = react_native_background_timer_1.default.clearTimeout.bind(react_native_background_timer_1.default);
        global.clearInterval = react_native_background_timer_1.default.clearInterval.bind(react_native_background_timer_1.default);
        global.setInterval = react_native_background_timer_1.default.setInterval.bind(react_native_background_timer_1.default);
        global.setTimeout = function (fn, ms) {
            if (ms === void 0) { ms = 0; }
            return react_native_background_timer_1.default.setTimeout(fn, ms);
        };
    }
    global.DailyNativeUtils = {
        //With React Native new architecture the Native modules are lazily initialized
        //As a result ...DailyNativeUtils won't work as expected because the actual properties aren't there yet.
        //New architecture known limitations: https://github.com/reactwg/react-native-new-architecture/discussions/237
        //With this approach mentioning each function, everything works fine with the compatibility layer.
        //More details about the compatibility layer here: https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here#gradual-migration
        setKeepDeviceAwake: DailyNativeUtils.setKeepDeviceAwake,
        setShowOngoingMeetingNotification: DailyNativeUtils.setShowOngoingMeetingNotification,
        presentSystemScreenCapturePrompt: DailyNativeUtils.presentSystemScreenCapturePrompt,
        requestStopSystemScreenCapture: DailyNativeUtils.requestStopSystemScreenCapture,
        isScreenBeingCaptured: DailyNativeUtils.isScreenBeingCaptured,
        isIOS: react_native_1.Platform.OS === 'ios',
        isAndroid: react_native_1.Platform.OS === 'android',
        setAudioMode: WebRTCModule.setDailyAudioMode,
        setAudioDevice: WebRTCModule.setAudioDevice,
        getAudioDevice: WebRTCModule.getAudioDevice,
        enableNoOpRecordingEnsuringBackgroundContinuity: WebRTCModule.enableNoOpRecordingEnsuringBackgroundContinuity,
        addAudioFocusChangeListener: function (listener) {
            audioFocusChangeListeners.add(listener);
        },
        removeAudioFocusChangeListener: function (listener) {
            audioFocusChangeListeners.delete(listener);
        },
        addAppStateChangeListener: function (listener) {
            appStateChangeListeners.add(listener);
        },
        removeAppStateChangeListener: function (listener) {
            appStateChangeListeners.delete(listener);
        },
        addSystemScreenCaptureStopListener: function (listener) {
            systemScreenCaptureStopListeners.add(listener);
        },
        removeSystemScreenCaptureStopListener: function (listener) {
            systemScreenCaptureStopListeners.delete(listener);
        },
        setSystemScreenCaptureStartCallback: function (listener) {
            systemScreenCaptureStartCallback = listener;
        },
        platform: react_native_1.Platform,
    };
}
setupEventListeners();
setupGlobals();
exports.default = daily_js_1.default;
__exportStar(require("@daily-co/daily-js"), exports);
__exportStar(require("@daily-co/react-native-webrtc"), exports);
