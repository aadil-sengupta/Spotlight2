"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addListener = addListener;
exports.removeListener = removeListener;
exports.setupNativeEvents = setupNativeEvents;
var _reactNative = require("react-native");
var _EventEmitter = _interopRequireDefault(require("react-native/Libraries/vendor/emitter/EventEmitter"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// @ts-ignore

const {
  WebRTCModule
} = _reactNative.NativeModules;

// This emitter is going to be used to listen to all the native events (once) and then
// re-emit them on a JS-only emitter.
const nativeEmitter = new _reactNative.NativeEventEmitter(WebRTCModule);
const NATIVE_EVENTS = ['peerConnectionSignalingStateChanged', 'peerConnectionStateChanged', 'peerConnectionOnRenegotiationNeeded', 'peerConnectionIceConnectionChanged', 'peerConnectionIceGatheringChanged', 'peerConnectionGotICECandidate', 'peerConnectionDidOpenDataChannel', 'peerConnectionOnRemoveTrack', 'peerConnectionOnTrack', 'dataChannelStateChanged', 'dataChannelReceiveMessage', 'dataChannelDidChangeBufferedAmount', 'mediaStreamTrackMuteChanged', 'mediaStreamTrackEnded', 'mediaDevicesOnDeviceChange'];
const eventEmitter = new _EventEmitter.default();
function setupNativeEvents() {
  for (const eventName of NATIVE_EVENTS) {
    nativeEmitter.addListener(eventName, (...args) => {
      eventEmitter.emit(eventName, ...args);
    });
  }
}
const _subscriptions = new Map();
function addListener(listener, eventName, eventHandler) {
  if (!NATIVE_EVENTS.includes(eventName)) {
    throw new Error(`Invalid event: ${eventName}`);
  }
  if (!_subscriptions.has(listener)) {
    _subscriptions.set(listener, []);
  }
  _subscriptions.get(listener)?.push(eventEmitter.addListener(eventName, eventHandler));
}
function removeListener(listener) {
  _subscriptions.get(listener)?.forEach(sub => {
    sub.remove();
  });
  _subscriptions.delete(listener);
}
//# sourceMappingURL=EventEmitter.js.map